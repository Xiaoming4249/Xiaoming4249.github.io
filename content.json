{"pages":[],"posts":[{"title":"Java学习--1--容器例程-城市里程","text":"Java学习过程中容器课程中的一个例程。 题目描述： 你的程序要读入这样的一张表，然后，根据输入的两个城市的名称，给出这两个城市之间的里程。 输入：首先，你会读到若干个城市的名字。每个名字都只是一个英文单词，中间不含空格或其他符号。当读到名字为“###”（三个#号）时，表示城市名字输入结束，###并不是一个城市的名字。如果记读到的城市名字的数量为n。 然后，你会读到nxn的一个整数矩阵。第一行的每一个数字，表示上述城市名单中第一个城市依次到另一个城市之间的里程。表中同一个城市之间的里程为0。 最后，你会读到两个城市的名字。 输出：输出这两个城市之间的距离。 解题关键： 容器 ArrayList() 和 HashMap() 的使用。 以HashMap类型对象作为HashMap的值。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package study;import java.util.ArrayList;import java.util.HashMap;import java.util.Scanner;public class City_distance { //城市数量 private int cityNumber = 0; //城市名称队列 ArrayList&lt;String&gt; City_name = new ArrayList&lt;String&gt;(); //城市里程散列表 HashMap&lt;String, HashMap&lt;String, Integer&gt;&gt; Dist_list = new HashMap&lt;&gt;(); Scanner in = new Scanner(System.in); //城市名称输入 private void NameInput() { while(true) { String name = in.next(); if (name.equals(&quot;###&quot;)) { break; } City_name.add(name); cityNumber ++; } } //城市里程输入 private void DistInput() { for(int i = 0;i &lt; cityNumber; i++) { HashMap&lt;String, Integer&gt; Dist_part = new HashMap&lt;&gt;(); for(int j = 0; j &lt; cityNumber; j ++) { int dist = in.nextInt(); Dist_part.put(City_name.get(j), dist); } Dist_list.put(City_name.get(i), Dist_part); } } //城市里程查找 private int DistFind(String city1, String city2) { return Dist_list.get(city1).get(city2); } public static void main(String[] args) { // TODO Auto-generated method stub Scanner in = new Scanner(System.in); City_distance cD = new City_distance(); cD.NameInput(); cD.DistInput(); System.out.print(&quot;请输入想要查询的两个城市名称：\\r\\n&quot;); System.out.printf(&quot;两个城市之间的距离是%dkm。&quot;, cD.DistFind(in.next(), in.next())); }}","link":"/2021/10/08/Java_1_%E5%AE%B9%E5%99%A8%E4%BE%8B%E7%A8%8B_%E5%9F%8E%E5%B8%82%E9%87%8C%E7%A8%8B/"},{"title":"Java学习笔记-0-入门","text":"Java使用时的一些入门级操作和相关概念，来源于mooc课程。 基本操作==输入:== 12345 import java.util.Scanner;​Scanner in = new Scanner(System.in);​变量名 = in.nextline() /in.nextInt() /in.nextDouble(); ==输出:== 1System.out.print(&quot;String&quot; + &quot;String&quot; +Int); ==定义数组：== 123456//一维数组int[] array_name = new int[array_size];//二维数组int[][] array_name = new int[raw_size][column_size];//String数组String[] s = new String[array_size]; 对象==字符类型==：Unicode ==包裹类型==： char ———— Characterint ———— Integerfloat ———— Floatlong ———— Longdouble ———— Doubleshort ———— Shortboolean ———— Booleanbyte ———— Byte 包裹类型作用：使用点运算符（“ . ”）对对象进行快捷操作 例1： Integer 12Integer.MIN_VALUE;//获取该类型的最小值Integer.MAX_VALUE;//获取该类型最大值 例2： Character 12345Character.isDigit(char ch);//判断字符是否是数字Character.isLetter(char ch);//判断字符是否是字母Character.isLetterOrDigit(char ch);//判断字符是否是字母或数字Character.isLowerCase(char ch);//判断字符是否是小写//UpperCase(大写)Whitespace(空格)Character.toLowerCase(char ch);//将字符转化为小写 ==字符串：== 创建： 123String s = new String(&quot;a string&quot;);//简化String s = &quot;hello&quot;; 字符串变量(StringBuffer 类型对象) 12StringBuffer sb = new StringBuffer();sb.append(&quot;string&quot;); 特点：管理类型，创建了管理字符串对象的变量 s 字符串输入： 12in.next();//读入一个单词，标志为空格（包括空格、tab和换行）in.nextLine();//读入一整行 字符串操作： 1234567891011121314//比较和查找s1.equals(s2);//s1和s2是否相同，返回bool值s1.compareTo(s2);//s1和s2比较大小，？？？？？str.length();//获取str长度str.charAt(index);//返回index上的单个字符（index从0到length-1）//拆子串str.substring(n);//得到n号位置到末尾的全部内容str.substring(b,e);//得到b号位置到e号位置之前的内容//寻找字符 //（从左往右，从右往左为s.lastIndexOf()）s.indexOf(c);//得到c字符或c字符串所在位置，-1表示不存在s.indexOf(c,n);//从n号位置开始找c//其他操作 函数==函数定义== [] 位置：class内，main外 例： 1234567891011121314151617181920public class Study{ //素数判断 public static boolean isPrime(int n) { boolean isPrime = true; for(int k=2;k&lt;n;k++) { if( n % k == 0 ){ isPrime = false; break; } } return isPrime; } public static void study() { // }} ==参数类型匹配== char–&gt;int–&gt;double （窄–&gt;宽） ==Java 调用函数时，永远只能传值给函数== ==变量的生存期和作用域== 生存期：开始出现—消亡 作用域：可以访问变量的范围 对于本地变量**——–》》大括号内{}** *","link":"/2021/10/01/Java_0_%E5%85%A5%E9%97%A8/"},{"title":"Java学习--1--面向对象","text":"Java类与对象的相关内容，还包括常用的数据容器介绍。 1、类与对象==对象==：实体，需要被创建，为我们做事； ​ 对象 =属性（数据，成员变量）+服务（操作，成员函数） ​ ==封装==：把数据和对数据的操作放在一起。（对象内的数据只能通过对象的操作来访问） ==类==：规范，根据类的定义创建对象。 1.1定义类和建立对象内容：成员变量+成员函数 例1（定义类）： 1234567891011121314151617//售货机public class VendingMachine{ //变量 int price; int balabnce; int total; //函数 void insertMoney(int amount)//投钱 { balance = balance + amount; } void showBalance()//显示余额 { System.out.println(balance); }} 例2（创建对象） 1VendingMachine v1 = new VendingMachine(); 例3（调用操作） 12//&quot;.&quot;运算符v1.showBalance(); ==在类内部,成员函数可直接调用成员变量和成员函数，有时可用”this.”节省打字时间== 本地变量：函数内部定义的变量，生存期和作用域都是函数内部 1.2对象初始化1、成员变量初始化定义类时给初值 or 建立对象时自动赋初值 2、构造函数类内名称和类名相同的函数，对象初始化时会被调用，可以有输入参数，但不能有返回值。 例 123456789VendingMachine(){ price = 2;}VendingMachine(int price){ this.price = price;} ==一个类中可以定义多个构造函数，对象初始化时根据输入参数调用对应的构造函数== ==构造函数内也可以调用其他构造函数== 2、对象交互2.1 对象识别与划分原则：属性和动作相似统一的可以视为同一类对象。 例：一个时钟可以看做小时和分钟两个同类型的计数器对象。 2.2 访问属性（一）封闭的访问属性“private” “private” 关键字，可用于成员变量和成员函数前 封闭属性成员只能被内部==成员函数==或==成员变量初始化==调用 ==问题讨论==：private的“封闭”针对的是类，而不是某一个对象，因此同一类的不同对象之间可以互相调用封闭类型变量。 （二）开放的访问属性“public” 可被任意函数调用 类也可以被定义为“public”属性，但一个编译单元（源文件）中只能有==一个==public类型的类，且==类的名称必须和源文件名称相同==。 （三）半开放属性“friendly” 定义变量和函数时没有加“private”或“public”即为该类型 该类变量和函数可被同一包内的其它函数调用 2.3 包(package) 包名—&gt;文件夹名 包间调用需要使用import 1import package_name.class_name; 2.4 类变量“static”类变量 1private static int classVarity = 1; 特点： 可以用 类名.类变量 or 对象名.类变量 的方式访问和赋值 同一类的对象中类变量的值都是相同的（对一个对象中的类变量赋值，同一类中其他对象中该值也会改变） 类变量的初始化只会进行一次 类函数 1234public static void f(){ //content of function} 特点： 函数内只能调用类变量和类函数 可以用 类名.类函数名 or 对象名.类函数名 的方式调用 3、对象容器3.1定义==容器类==： 两个类型： 容器的类型 元素的类型 例： 12ArrayList&lt;String&gt; notes = new ArrayList&lt;String&gt;;//元素类型为字符串的ArrayList容器 ==对象数组==： 例： 12//String数组String[] s = new String[array_size]; 当数组的元素的类型是类的时候，数组的每一个元素其实只是对象的管理者而不是对象本身。 对象数组的for each操作 例： 12345String[] str = new String[array_size];for(String s : str){ //对str字符串数组中的字符串进行操作} 3.2 集合容器1HashSet&lt;String&gt; notes = new HashSet&lt;String&gt;; 集合中的元素没有顺序 元素不能重复 ==public String toString(){return “”+varity_class;}== 当一个类中有上述函数时，可直接用 ==System.out.println(该类对象)==输出return后的值（转化为字符串） 3.3 Hash 散列表123HashMap&lt;Interger, String&gt; coinname = new HashMap&lt;Interger, String&gt;;//放值coinname.put(1,&quot;penny&quot;); Hash内元素为键值对 键是唯一的 定义时尖括号内必须为包裹类型 ==遍历方法：== 123456for(Integer k : coinname.keySet()){ String s = coinname.get(k); //对s操作}//思路：遍历键，由键及值 4、继承与多态4.1 父类和子类==使用场景：==在一个工程中有两个或多个内容相似、相近的类，可使用父类表达，以减少代码复制，提高代码质量和可维护性 建立子类： 12345678910111213public class DVD extends Item{ //private String title;//在父类中进行定义 private int playtime; private String title;//当父类和子类中有同名变量，会发生什么？（看下面） public DVD(String title, int playtime){ //this.title = title; supper(title);//调用父类中参数为一个字符串的构造器，即将title传递给父类构造器 this.playtime = playtime; } } 对应父类： 123456789101112public class Item{ private String title; public Item(String title){ super(); this.title = title; } public print() { } } 主函数内容： 12 4.2 继承 ==DVD是Item的子类== 可以继承父类中的变量和函数 不能使用private类型 可设置变量或函数为protected类型，则子类可调用 也可用super（）函数进行参数传递 ==super()函数和参数传递== 可将子类构造函数的参数传递到父类的构造函数 程序流程：new Item(一堆参数) –跳转到DVD构造——-&gt;DVD()–运行到super（）——-&gt;super()–super的意思就是调用Item中的构造函数-&gt;Item()—&gt;DVD() 当子类构造函数中没有写super()时，默认自动存在不含参数的super（）（会去调用父类无参数构造器） ==父类子类同名参数== 子类中调用该变量时，父类中的会被隐藏（就近原则） 父类中调用时使用的依然是父类中的变量 ==父类子类同名函数== 子类中调用父类同名函数使用super.funname() ==总结：== 类定义了类型 子类定义了子类型 子类的对象可以被当作父类的对象来使用 赋值给父类的变量 传递给需要父类对象的函数 放进存放父类对象的容器 4.3 多态变量 内涵： java的对象变量（父类对象）是多态的，它们能保存不止一种类型的对象 它们可以保存声明类型的对象，或声明类型的子类的对象 当把子类的对象赋给父类的变量的时候，就发生了向上造型 向上造型： 子类的对象可以赋值给父类的变量 父类的对象不能赋值给子类的变量 可以用造型 ==造型与类型转换== 造型时对象不发生改变（管理者改变） 类型转换时对象会发生变化（对象改变） 123456Vechicle v;Car c = new Car();//car是vechicle的子类v = c;//rightc = v;//编译错误c = (Car) v;//编译没有问题，但运行时需要v实际管理的是car类型变量，否则会报造型异常错误 多态： 声明类型与动态类型： 函数调用的绑定： 当通过对象变量调用函数的时候，调用那个函数这件事叫做绑定（==java函数默认动态调用==） 静态绑定：根据变量的声明类型来决定（编译时绑定） 动态绑定：根绝变量的动态类型来决定（运行过程中绑定） 成员函数中调用其他成员函数也是通过this这个对象变量来调用 覆盖override： 子类he父类中存在名称和参数表完全相同的函数，这一对函数构成覆盖关系 通过父类的变量调用存在覆盖关系的函数，会调用变量当时所管理的对象所属的类的函数（动态绑定） 4.4 Object类==所有的类都是继承自Object的== DoME的新媒体类型 （例子） 5. 代码升级 减少复制代码 降低类间的耦合 用封装，留接口 用接口来实现聚合 用容器来实现灵活 以框架加数据提高可扩展性 定义Handler处理命令 用Hash表来保存命令和Handler之间的关系 123public class Handler{ }","link":"/2021/10/06/Java_1_%E7%BB%A7%E7%BB%AD%E5%85%A5%E9%97%A8/"},{"title":"Linux+Hexo+yilia主题--个人博客搭建","text":"学习代码找工作，建立自己的个人博客既是对自己学习过程成果的记录，也算一项项目经历，因此搭建了这个博客站。感谢up主CodeSheep和各位网友经验的教导，在这里对整个搭建过程进行一下总结。 1. Linux环境搭建服务器相关信息： 来源：阿里云 版本：Ubuntu 18.04.6 相关工具：Putty、WinSCP 1.1 安装和配置node.js安装方法： 1、官网下载适合linux–Linux二进制文件（x64）（链接：http://nodejs.cn/download/）。 ==uname -a==命令可以获得linux系统位数。 2、下载得到 ==node-v16.14.0-linux-x64.tar.xz== 压缩包，使用WinSCP上传至服务器任意目录，使用tar命令解压即安装完成。 1tar -xvf node-v16.14.0-linux-x64.tar.xz ​ （为了之后方便，把解压后的文件夹名改为nodejs） 3、建立==软链接==，使npm、node命令可用，使用==ln -s==命令。 123ln -s /root/programs/nodejs/bin/npm /bin/ln -s /root/programs/nodejs/bin/node /bin/# ln -s 源文件路径（必须为绝对路径，从根目录/写起） 软链接位置路径（设置为系统bin目录，使得npm和node可以运行） ​ 建立完成后可以使用 node -v和npm -v指令检验软连接是否建立成功 （tips：后面还需用到git，但服务器本身已经默认装过了，所以不需要装，有需要可以参考https://blog.csdn.net/qq_37908043/article/details/89065586?spm=1001.2014.3001.5502） 1.2 安装和初始化hexo 1、安装：可以直接使用==npm install==命令安装 1npm i hexo-cli -g ​ 若太慢，可以用淘宝源： 123npm install -g cnpm --registry=http://registry.npm.taobao.org #安装淘宝的cnpm 管理器cnpm -v #查看cnpm版本cnpm install -g hexo-cli #安装hexo框架 2、建立软连接：使hexo命令可用，hexo在nodejs中的路径为==nodejs/lib/node_modules/hexo-cli/bin/hexo==，完成后可以用hexo -v指令检验 1ln -s /root/programs/nodejs/lib/node_modules/hexo-cli/bin/hexo /bin/hexo (这里后面只链接bin就不行了，不知道啥情况，链接到/bin/hexo就可以 -_-! ) 3、在合适的位置建立blog文件夹，之后的操作都在这里，然后进入该目录，指令如下 12mkdir blogcd blog 4、hexo初始化，使用==hexo init==命令，会在blog文件夹下生成hexo框架所需的文件和目录，hexo常用命令如下，更多内容可参考官方文档https://hexo.io/zh-cn/docs/： 123456hexo init #生成博客 初始化博客hexo s #启动本地博客服务hexo n &lt;title&gt; #生成新文章hexo c #清理一下hexo g #生成hexo d #部署到远程Github仓库 init完成后，可以使用==hexo s== 命令运行，提示成功运行在http：localhost：4000即表明运行成功。 5、tips： Linux关于进程操作的一些指令，可以在未正常关闭hexo进程时解决4000端口占用问题。 123ps #显示正在运行的进程相关信息jobs #当前会话再进行的工作fg #将后台的命令调至前台进行 1.3 浏览器访问 1、云服务器安全组设置，配置安全组规则，开放4000端口的TCP连接。 2、浏览器输入：http：&lt;域名&gt; or &lt;ip地址&gt;:4000，即可访问。 2、主题更换和相关修改2.1 yilia主题更换同样在blog文件夹下进行操作。 1、从github上下载源码，使用==git clone==指令。 1git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia ​ 下载完成后，文件夹路径为==blog/themes/yilia==。 2、修改根目录（blog）下配置文件_config.yml，以替换默认主题。 可以使用vim打开文件，vim具体使用方法可以浏览菜鸟教程（https://www.runoob.com/linux/linux-tutorial.html）。 1234vim _config.yml#按i进入编辑模式#找到theme（一般在最下面），将后面的landscape改为yilia#esc，然后使用冒号指令wq保存退出 3、修改完成后重新启动hexo，并通过浏览器访问查看。 2.2 yilia相关个性化修改（可以查看yilia给出的教程完成初步修改） 1、安装缺失组件。（修正全部文章无法显示等问题） 同样在blog目录下进行 首先运行以下命令，安装相关程序。 1npm i hexo-generator-json-content --save 再修改blog目录下的_config.yml文件，在空位添加以下代码： 123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: true tags: true 2、更换头像。 需要修改yilia文件夹中的_config.yml配置文件，将你要修改的头像放在source/img/目录下，然后将avatar后的url改成/img/你的头像名.jpg，具体如下： 12#你的头像urlavatar: /img/head.jpg 3、文章内容相关。 （1）如果是在本地编辑的md文件，直接传上去，没有自动生成的标题和时间等信息，在md文件顶端加上以下内容即可： 12345---title: 标题date: 2022-02-22tags: Hexo--- （2）内容截断，要让首页不显示全部文章内容需要进行文章截断，只需要在需截断处加上more标志即可。 1&lt;!-- more --&gt; （3）插入图片。实现这个的时候踩的坑比较多，主要是建站是hexo版本为5.4，与以前的不相符，官方提供的方式也并不好用，其实hexo5版本以后图片插入比较方便，下面说正确姿势。 首先要更改blog目录下的_config.yml文件，将post_asset_folder属性改为true，然后在 ==/blog/source/==文件夹下建立专门放图片的文件夹（如/images），然后将图片传进去，之后在md文件中插入图片时将路径改好即可，具体插入方式如下： 12![图片描述](/images/图片名)#当然在images文件夹下建立多级文件夹也是可以的，只要路径写对即可。 3、待解决的问题 1、md文件、图片路径和图片自动更改和上传的问题。 （使用WinSCP的自动同步功能可以解决） 2、域名问题。（买一个就行了，不是啥问题）。 3、进站需要输入端口号问题，解决思路80端口或者a代理。 4、 参考CodeSheep教程：https://www.bilibili.com/video/BV1Yb411a7ty yilia主题相关：https://www.jianshu.com/p/f6f19b02c661 Linux安装Hexo：https://blog.csdn.net/qq_37908043/article/details/89066858?spm=1001.2014.3001.5502 Linux停止进程教程：https://www.linuxprobe.com/linux-kill-process.html Linux菜鸟教程：https://www.runoob.com/linux/linux-tutorial.html 网友的个人总结：https://www.bilibili.com/read/cv12633102","link":"/2022/03/04/Linux-Hexo-yilia%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"title":"Koa基础学习笔记","text":"使用koa框架搭建web服务的基本方法，包括一些比较重要的组件和它的使用方法。 Koa基于Node.js平台的下一代web开发框架 简介：koa 是由 Express 原班人马打造的，致力于成为一个更小、更富有表现力、更健壮的 Web 框架。使用 koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升错误处理的效率。koa不在内核方法中绑定任何中间件，它仅仅提供了一个轻量优雅的函数库，使得编写 Web 应用变得得心应手。 1 koa安装和简单调用 VS code node应用项目初始化： 1npm init ​ *项目初始化，生成项目package.json包主要作用在于管理依赖 安装koa: 1npm i koa --save ​ *安装kao，并将安装信息保存在package中（–save的作用），这样别人使用该项目时即会自动安装koa支持 koa调用 12const Koa = require('koa');const app = new Koa(); 自动重启功能 实现方法：nodemon包 安装： 123456npm i nodemon -g//全局安装npm i nodemon --save-dev//添加依赖安装，-dev表示只在开发阶段用，此时调用需要修改package中的脚本（如下）&quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;nodemon index.js&quot; }//添加语句start 运行 1npm start 2 koa-router路由管理 安装 1npm install koa-router --save 功能 基本路由功能：识别url、识别http请求类型、识别url中的参数 高级功能：前缀和多中间件 例程 123456789101112131415161718192021222324252627282930313233343536373839const Koa = require('koa');const Router = require('koa-router');const app = new Koa();const router = new Router();//创建router实例const Userrouter = new Router({prefix:'/users'});//前缀const auth = async (ctx,next) =&gt; { if (ctx.url !== '/users'){ ctx.throw(401); } await next();}router.get('/',(ctx) =&gt; { ctx.body = 'This is the first page!'});// router.get('/users',(ctx) =&gt; {// ctx.body = 'This is the list of users!'// });//改为前缀式使代码更简洁Userrouter.get('/',auth,(ctx) =&gt; { ctx.body = 'This is the list of users!'});Userrouter.post('/',(ctx) =&gt; { ctx.body = 'Add a new user!'});router.get('/users/:id',(ctx) =&gt; { ctx.body = `This is the user named ${ctx.params.id}!`;});app.use(router.routes());app.use(Userrouter.routes());app.listen(8888); 3 HTTP options方法 作用 检测服务器支持的请求方法（allowedMethods） CORS中的预检请求 调用方法 12app.use(Userrouter.allowedMethods());//添加该中间件即可 405和501 当启用options方法时，若采用koa可实现但并未写入服务器的访问方法时，返回405（不允许）；若采用koa不可实现的方法时，返回501(无法实现) 4 RESTful API最佳实践——增删改查返回响应 查： 返回所查数组 增：返回增加项 改：返回修改后的项 删：返回状态204 5 控制器（一种中间件） 作用： 获取参数 处理逻辑 返回响应 HTTP请求参数： Query string（url中？后的内容，用于内容筛选） Router Params（url中的参数） Body（请求体的主要内容） Header（Accept、Cookie） 发送HTTP响应 Status（状态码） Body（响应主题内容） Header（Allow、Content-Type） 6 最佳实践注意点 分文件夹： 路由放在单独目录 控制器放在单独目录 使用类加类方法的方式组织控制器 路由： 针对不同功能的路由写在不同文件中 一个文件中路由调用和书写： 123456789101112131415161718//引用koa-router，建立类Routerconst Router = require('koa-router');//建立Router实例router，添加前缀const router = Router({prefix:'/users'});//调用控制器中的函数const { getUsers, findUser, addUser, changeUser, deleteUser} = require('../controllers/user');router.get('/',getUsers);router.post('/',addUser);router.get('/:id',findUser);router.put('/:id', changeUser);router.delete('/:id',deleteUser);//导出为router模块module.exports = router; 路由文件的整体管理fs 写了多个路由文件，一个一个导入太慢，可以使用node.js的文件管理功能，专门设置一个index.js，遍历文件夹中的各个路由文件，并将路由信息导入。 1234567891011121314//node.js的文件管理系统fsconst fs = require('fs');module.exports = (app) =&gt; { fs.readdirSync(__dirname).forEach(file =&gt;{ //跳过index.js if (file === 'index.js'){ return; } const route = require(`./${file}`); //使用routes方法导入中间件，添加allowedMethods中间件，可返回该路由允许访问的方法 app.use(route.routes()).use(route.allowedMethods()); })} 控制器 以“类+类的方法”构造控制器代码 记得exports 12345678910111213141516171819202122232425262728const db = [{name: 'lilei'}];class UsersCtrl { getUsers(ctx){ ctx.body = db; } findUser(ctx){ ctx.body = db[ctx.params.id * 1]; } changeUser(ctx){ db[ctx.params.id * 1] = ctx.body; ctx.body = ctx.body; } addUser(ctx){ db.push(ctx.body); ctx.body = ctx.request.body; //console.log(ctx.request.body); } deleteUser(ctx){ db.splice(ctx.params.id * 1,1); ctx.status = 204; }}module.exports = new UsersCtrl(); 主程序 调用routes的方法，看例程(routing) 注意中间件的添加顺序（洋葱模型），保证下一步所用的参数已在上一个中间件中解析出来 1234567891011const Koa = require('koa');// const body = require('koa-body');const bodyparser = require('koa-bodyparser');const routing = require('./routes');const app = new Koa();app.use(bodyparser());routing(app);// app.use(body());app.listen(8888, () =&gt; console.log('程序启动成功，正在监听8888端口...')); 7 错误处理 koa-json-error的使用 调用： 1const err = require('koa-json-error'); 使用： 123456app.use(err({ postFormat:(e,{stack,...rest})=&gt;process.env.NODE_ENV === 'production' ? rest:{stack,...rest}}));//对error组件的调用要在最前面，洋葱模型最外层//上代码功能为返回错误信息，判断服务器运行模式，开发时返回错误堆栈，应用时不返回//其中NODE_ENV为环境变量，可在scripts中设置 cross-env的使用 该模块是为了解决windows环境下不能直接在scripts中设置环境变量的问题 1234567&quot;scripts&quot;:{ &quot;start&quot;: &quot;cros-env NODE_ENV=production node app/sever.js&quot;, &quot;dev&quot;:&quot;nodemon app/sever.js&quot;}//start:应用模式下启动服务器//run dev:开发模式下启动//tips:在脚本中不能随便打空格，如等号两边 8 参数校验 koa-parameter使用 调用与使用 1234567const parameter = require('koa-parameter');...app.use(bodyparser());app.use(parameter(app));//通常要用来校验请求体，因此要放在body后面routing(app); 具体设置：（在控制器函数中设置） 123456789addUser(ctx){ ctx.verifyParams({ name: {type: 'string', required: true}, age: {type: 'int', required: false} }) db.push(ctx.request.body); ctx.body = ctx.request.body; console.log(ctx.request.body); }","link":"/2021/10/20/koa/"},{"title":"模板文件","text":"","link":"/1900/01/01/test/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Koa","slug":"Koa","link":"/tags/Koa/"},{"name":"muban","slug":"muban","link":"/tags/muban/"}],"categories":[]}